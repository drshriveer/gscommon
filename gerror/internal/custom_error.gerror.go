// Code generated by gerror DO NOT EDIT.
package internal

import (
	"fmt"

	"github.com/drshriveer/gtools/gerror"
)

// Error implements the "error" interface.
func (e *GRPCError) Error() string {
	const separator = ", "
	result := ""
	if name := e.GError.Name; len(name) > 0 {
		result += "Name: " + name + separator
	}
	if dTag := e.GError.ErrDetailTag(); len(dTag) > 0 {
		result += "DTag: " + dTag + separator
	}
	if src := e.GError.Source; len(src) > 0 {
		result += "Source: " + src + separator
	}
	result += fmt.Sprintf("CustomerMessage: %v", e.CustomerMessage) + separator
	result += fmt.Sprintf("GRPCStatus: %v", e.GRPCStatus) + separator

	result += "Message: " + e.Message

	// Note: right now if we have a "source stack", we actually remove the stack after calculations.
	if stack := e.GError.ErrStack(); len(stack) > 0 {
		result += "\n" + stack.String()
	}

	return result
}

func (e *GRPCError) Base() gerror.Error {
	clone := gerror.CloneBase(e, gerror.NoStack, "", "", "", nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) SourceOnly() gerror.Error {
	clone := gerror.CloneBase(e, gerror.SourceStack, "", "", "", nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) Stack() gerror.Error {
	clone := gerror.CloneBase(e, gerror.DefaultStack, "", "", "", nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) Src(src string) gerror.Error {
	clone := gerror.CloneBase(e, gerror.SourceStack, "", src, "", nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) DTag(dTag string) gerror.Error {
	clone := gerror.CloneBase(e, gerror.SourceStack, dTag, "", "", nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) Msg(format string, elems ...any) gerror.Error {
	clone := gerror.CloneBase(e, gerror.SourceStack, "", "", fmt.Sprintf(format, elems...), nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) SrcDTagMsg(src, dTag, format string, elems ...any) gerror.Error {
	clone := gerror.CloneBase(e, gerror.SourceStack, dTag, src, fmt.Sprintf(format, elems...), nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) SrcDTag(src, dTag string) gerror.Error {
	clone := gerror.CloneBase(e, gerror.SourceStack, dTag, src, "", nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) SrcMsg(src, format string, elems ...any) gerror.Error {
	clone := gerror.CloneBase(e, gerror.SourceStack, "", src, fmt.Sprintf(format, elems...), nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) DTagMsg(dTag, format string, elems ...any) gerror.Error {
	clone := gerror.CloneBase(e, gerror.SourceStack, dTag, "", fmt.Sprintf(format, elems...), nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) SrcS(src string) gerror.Error {
	clone := gerror.CloneBase(e, gerror.DefaultStack, "", "", "", nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) DTagS(dTag string) gerror.Error {
	clone := gerror.CloneBase(e, gerror.DefaultStack, dTag, "", "", nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) MsgS(format string, elems ...any) gerror.Error {
	clone := gerror.CloneBase(e, gerror.DefaultStack, "", "", fmt.Sprintf(format, elems...), nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) SrcDTagMsgS(src, dTag, format string, elems ...any) gerror.Error {
	clone := gerror.CloneBase(e, gerror.DefaultStack, dTag, src, fmt.Sprintf(format, elems...), nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) SrcDTagS(src, dTag string) gerror.Error {
	clone := gerror.CloneBase(e, gerror.DefaultStack, dTag, src, "", nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) SrcMsgS(src, format string, elems ...any) gerror.Error {
	clone := gerror.CloneBase(e, gerror.DefaultStack, "", src, fmt.Sprintf(format, elems...), nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) DTagMsgS(dTag, format string, elems ...any) gerror.Error {
	clone := gerror.CloneBase(e, gerror.DefaultStack, dTag, "", fmt.Sprintf(format, elems...), nil)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) Convert(err error) gerror.Error {
	if gerr, ok := err.(gerror.Error); ok {
		return gerr
	}
	clone := gerror.CloneBase(e, gerror.SourceStack, "", "", fmt.Sprintf("originalError: %+v", err), err)
	return e.toPrimaryType(clone)
}

func (e *GRPCError) ConvertS(err error) gerror.Error {
	if gerr, ok := err.(gerror.Error); ok {
		return gerr
	}
	clone := gerror.CloneBase(e, gerror.DefaultStack, "", "", fmt.Sprintf("originalError: %+v", err), err)
	return e.toPrimaryType(clone)
}

// toPrimaryType accepts a base gerror and will populate clone fields.
func (e *GRPCError) toPrimaryType(gerr *gerror.GError) gerror.Error {
	result := &GRPCError{
		GError:          *gerr,
		CustomerMessage: e.CustomerMessage,
		GRPCStatus:      e.GRPCStatus,
		Timeout:         e.Timeout,
	}
	return result
}
