// Code generated by genum DO NOT EDIT.
package internal

import (
	"encoding/json"
	"fmt"
	"slices"
	"strings"

	"github.com/drshriveer/gtools/genum"
	"gopkg.in/yaml.v3"
)

var _DimensionOneValues = []DimensionOne{
	D1a,
	D1b,
	D1c,
	D1d,
}

// IsValid returns true if the enum value is, in fact, valid.
func (e DimensionOne) IsValid() bool {
	for _, v := range _DimensionOneValues {
		if v == e {
			return true
		}
	}
	return false
}

// Values returns a list of all potential values of this enum.
func (DimensionOne) Values() []DimensionOne {
	return slices.Clone(_DimensionOneValues)
}

// StringValues returns a list of all potential values of this enum as strings.
// Note: This does not return duplicates.
func (DimensionOne) StringValues() []string {
	return []string{
		"D1a",
		"D1b",
		"D1c",
		"D1d",
	}
}

// String returns a string representation of this enum.
// Note: in the case of duplicate values only the first alphabetical definition will be choosen.
func (e DimensionOne) String() string {
	switch e {
	case D1a:
		return "D1a"
	case D1b:
		return "D1b"
	case D1c:
		return "D1c"
	case D1d:
		return "D1d"
	default:
		return fmt.Sprintf("UndefinedDimensionOne:%d", e)
	}
}

// ParseString will return a value as defined in string form.
func (e DimensionOne) ParseString(text string) (DimensionOne, error) {
	return ParseDimensionOne(text)
}

// ParseDimensionOne will attempt to parse the value of a DimensionOne from either its string form
// or any value of a trait flagged with the --parsableByTrait flag
func ParseDimensionOne(input any) (DimensionOne, error) {
	switch input {
	case "D1a":
		return D1a, nil
	case "D1b":
		return D1b, nil
	case "D1c":
		return D1c, nil
	case "D1d":
		return D1d, nil
	default:
		if text, ok := input.(string); ok {
			switch strings.ToLower(text) {
			case "d1a":
				return D1a, nil
			case "d1b":
				return D1b, nil
			case "d1c":
				return D1c, nil
			case "d1d":
				return D1d, nil
			}
		}
		return 0, fmt.Errorf("`%+v` could not be parsed to enum of type DimensionOne", input)
	}
}

// ParseGeneric calls TypedEnum.Parse but returns the result
// in the generic genum.Enum interface. Which is useful when you are only able to work with
// the un-typed interface.
func (e DimensionOne) ParseGeneric(input any) (genum.Enum, error) {
	return ParseDimensionOne(input)
}

// MarshalJSON implements the json.Marshaler interface for DimensionOne.
func (e DimensionOne) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for DimensionOne.
func (e *DimensionOne) UnmarshalJSON(data []byte) error {
	// We always support strings.
	var s string
	if err := json.Unmarshal(data, &s); err == nil {
		var err error
		*e, err = ParseDimensionOne(s)
		if err == nil {
			return nil
		}
	}

	return fmt.Errorf("unable to unmarshal DimensionOne from `%v`", data)
}

// MarshalText implements the encoding.TextMarshaler interface for DimensionOne.
func (e DimensionOne) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for DimensionOne.
func (e *DimensionOne) UnmarshalText(text []byte) error {
	s := string(text)
	var err error
	*e, err = ParseDimensionOne(s)
	if err == nil {
		return nil
	}

	return fmt.Errorf("unable to unmarshal DimensionOne from `%s`", s)
}

// MarshalYAML implements a YAML Marshaler for DimensionOne.
func (e DimensionOne) MarshalYAML() (any, error) {
	return e.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for DimensionOne.
func (e *DimensionOne) UnmarshalYAML(value *yaml.Node) error {
	var err error

	// first try and parse as a string
	*e, err = ParseDimensionOne(value.Value)
	if err == nil {
		return nil
	}

	// then try and parse for any string-like traits

	return fmt.Errorf("unable to unmarshal DimensionOne from yaml `%s`", value.Value)
}

// IsEnum implements an empty function required to implement Enum.
func (DimensionOne) IsEnum() {}

var _DimensionTwoValues = []DimensionTwo{
	D2a,
	D2b,
	D2c,
	D2d,
	D2e,
}

// IsValid returns true if the enum value is, in fact, valid.
func (e DimensionTwo) IsValid() bool {
	for _, v := range _DimensionTwoValues {
		if v == e {
			return true
		}
	}
	return false
}

// Values returns a list of all potential values of this enum.
func (DimensionTwo) Values() []DimensionTwo {
	return slices.Clone(_DimensionTwoValues)
}

// StringValues returns a list of all potential values of this enum as strings.
// Note: This does not return duplicates.
func (DimensionTwo) StringValues() []string {
	return []string{
		"D2a",
		"D2b",
		"D2c",
		"D2d",
		"D2e",
	}
}

// String returns a string representation of this enum.
// Note: in the case of duplicate values only the first alphabetical definition will be choosen.
func (e DimensionTwo) String() string {
	switch e {
	case D2a:
		return "D2a"
	case D2b:
		return "D2b"
	case D2c:
		return "D2c"
	case D2d:
		return "D2d"
	case D2e:
		return "D2e"
	default:
		return fmt.Sprintf("UndefinedDimensionTwo:%d", e)
	}
}

// ParseString will return a value as defined in string form.
func (e DimensionTwo) ParseString(text string) (DimensionTwo, error) {
	return ParseDimensionTwo(text)
}

// ParseDimensionTwo will attempt to parse the value of a DimensionTwo from either its string form
// or any value of a trait flagged with the --parsableByTrait flag
func ParseDimensionTwo(input any) (DimensionTwo, error) {
	switch input {
	case "D2a":
		return D2a, nil
	case "D2b":
		return D2b, nil
	case "D2c":
		return D2c, nil
	case "D2d":
		return D2d, nil
	case "D2e":
		return D2e, nil
	default:
		if text, ok := input.(string); ok {
			switch strings.ToLower(text) {
			case "d2a":
				return D2a, nil
			case "d2b":
				return D2b, nil
			case "d2c":
				return D2c, nil
			case "d2d":
				return D2d, nil
			case "d2e":
				return D2e, nil
			}
		}
		return 0, fmt.Errorf("`%+v` could not be parsed to enum of type DimensionTwo", input)
	}
}

// ParseGeneric calls TypedEnum.Parse but returns the result
// in the generic genum.Enum interface. Which is useful when you are only able to work with
// the un-typed interface.
func (e DimensionTwo) ParseGeneric(input any) (genum.Enum, error) {
	return ParseDimensionTwo(input)
}

// MarshalJSON implements the json.Marshaler interface for DimensionTwo.
func (e DimensionTwo) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for DimensionTwo.
func (e *DimensionTwo) UnmarshalJSON(data []byte) error {
	// We always support strings.
	var s string
	if err := json.Unmarshal(data, &s); err == nil {
		var err error
		*e, err = ParseDimensionTwo(s)
		if err == nil {
			return nil
		}
	}

	return fmt.Errorf("unable to unmarshal DimensionTwo from `%v`", data)
}

// MarshalText implements the encoding.TextMarshaler interface for DimensionTwo.
func (e DimensionTwo) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for DimensionTwo.
func (e *DimensionTwo) UnmarshalText(text []byte) error {
	s := string(text)
	var err error
	*e, err = ParseDimensionTwo(s)
	if err == nil {
		return nil
	}

	return fmt.Errorf("unable to unmarshal DimensionTwo from `%s`", s)
}

// MarshalYAML implements a YAML Marshaler for DimensionTwo.
func (e DimensionTwo) MarshalYAML() (any, error) {
	return e.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for DimensionTwo.
func (e *DimensionTwo) UnmarshalYAML(value *yaml.Node) error {
	var err error

	// first try and parse as a string
	*e, err = ParseDimensionTwo(value.Value)
	if err == nil {
		return nil
	}

	// then try and parse for any string-like traits

	return fmt.Errorf("unable to unmarshal DimensionTwo from yaml `%s`", value.Value)
}

// IsEnum implements an empty function required to implement Enum.
func (DimensionTwo) IsEnum() {}

var _DimensionThreeValues = []DimensionThree{
	D3a,
	D3b,
	D3c,
}

// IsValid returns true if the enum value is, in fact, valid.
func (e DimensionThree) IsValid() bool {
	for _, v := range _DimensionThreeValues {
		if v == e {
			return true
		}
	}
	return false
}

// Values returns a list of all potential values of this enum.
func (DimensionThree) Values() []DimensionThree {
	return slices.Clone(_DimensionThreeValues)
}

// StringValues returns a list of all potential values of this enum as strings.
// Note: This does not return duplicates.
func (DimensionThree) StringValues() []string {
	return []string{
		"D3a",
		"D3b",
		"D3c",
	}
}

// String returns a string representation of this enum.
// Note: in the case of duplicate values only the first alphabetical definition will be choosen.
func (e DimensionThree) String() string {
	switch e {
	case D3a:
		return "D3a"
	case D3b:
		return "D3b"
	case D3c:
		return "D3c"
	default:
		return fmt.Sprintf("UndefinedDimensionThree:%d", e)
	}
}

// ParseString will return a value as defined in string form.
func (e DimensionThree) ParseString(text string) (DimensionThree, error) {
	return ParseDimensionThree(text)
}

// ParseDimensionThree will attempt to parse the value of a DimensionThree from either its string form
// or any value of a trait flagged with the --parsableByTrait flag
func ParseDimensionThree(input any) (DimensionThree, error) {
	switch input {
	case "D3a":
		return D3a, nil
	case "D3b":
		return D3b, nil
	case "D3c":
		return D3c, nil
	default:
		if text, ok := input.(string); ok {
			switch strings.ToLower(text) {
			case "d3a":
				return D3a, nil
			case "d3b":
				return D3b, nil
			case "d3c":
				return D3c, nil
			}
		}
		return 0, fmt.Errorf("`%+v` could not be parsed to enum of type DimensionThree", input)
	}
}

// ParseGeneric calls TypedEnum.Parse but returns the result
// in the generic genum.Enum interface. Which is useful when you are only able to work with
// the un-typed interface.
func (e DimensionThree) ParseGeneric(input any) (genum.Enum, error) {
	return ParseDimensionThree(input)
}

// MarshalJSON implements the json.Marshaler interface for DimensionThree.
func (e DimensionThree) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for DimensionThree.
func (e *DimensionThree) UnmarshalJSON(data []byte) error {
	// We always support strings.
	var s string
	if err := json.Unmarshal(data, &s); err == nil {
		var err error
		*e, err = ParseDimensionThree(s)
		if err == nil {
			return nil
		}
	}

	return fmt.Errorf("unable to unmarshal DimensionThree from `%v`", data)
}

// MarshalText implements the encoding.TextMarshaler interface for DimensionThree.
func (e DimensionThree) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for DimensionThree.
func (e *DimensionThree) UnmarshalText(text []byte) error {
	s := string(text)
	var err error
	*e, err = ParseDimensionThree(s)
	if err == nil {
		return nil
	}

	return fmt.Errorf("unable to unmarshal DimensionThree from `%s`", s)
}

// MarshalYAML implements a YAML Marshaler for DimensionThree.
func (e DimensionThree) MarshalYAML() (any, error) {
	return e.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for DimensionThree.
func (e *DimensionThree) UnmarshalYAML(value *yaml.Node) error {
	var err error

	// first try and parse as a string
	*e, err = ParseDimensionThree(value.Value)
	if err == nil {
		return nil
	}

	// then try and parse for any string-like traits

	return fmt.Errorf("unable to unmarshal DimensionThree from yaml `%s`", value.Value)
}

// IsEnum implements an empty function required to implement Enum.
func (DimensionThree) IsEnum() {}
