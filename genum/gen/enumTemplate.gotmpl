// Code generated by genum DO NOT EDIT.
package {{.PkgName}}

import (
	"slices"
	{{- if .GenJSON}}
	"encoding/json"
	{{- end}}
	{{- if .CaseInsensitive}}
	"strings"
	{{- end}}
	{{- if .GenYAML}}
	"gopkg.in/yaml.v3"
	"strconv"
	{{- end}}
	{{- range $import := $.Imports.GetActive}}
	{{$import.Alias}} "{{$import.PkgPath}}"
	{{- end}}
	"fmt"
	"github.com/drshriveer/gtools/genum"
)
{{- range $i, $enumTypeName := .Types}}
{{- $values := (index $.Values $i)}}

var _{{$enumTypeName}}Values = []{{$enumTypeName}}{
{{- range $val := $values.ValueDeduplicatedSet}}
	{{$val.Name}},
{{- end }}
}
{{- range $trait := (index $.Traits $i)}}

// {{$trait.Name}} returns the enum's associated trait of the same name.
// If no trait exists for the enumeration a default value will be returned.
func (e {{$enumTypeName}}) {{$trait.Name}}() {{$trait.TypeRef}} {
	switch e {
	{{- range $instance := $trait.Traits}}
	case {{$instance.OwningValue.Name}}:
		return {{$instance.Value}}
	{{- end }}
	}

	return *new({{$trait.TypeRef}})
}
{{ end }}

// IsValid returns true if the enum value is, in fact, valid.
func (e {{$enumTypeName}}) IsValid() bool {
	{{- /*turns out it's probably faster to do a binary search if there are more than 15 values.*/}}
	{{- if gt (len $values) 15}}
	_, ok := slices.BinarySearch(_{{$enumTypeName}}Values, e)
	return ok
	{{- else}}
	for _, v := range _{{$enumTypeName}}Values {
		if v == e {
			return true
		}
	}
	return false
	{{- end}}
}

// Values returns a list of all potential values of this enum.
func ({{$enumTypeName}}) Values() []{{$enumTypeName}} {
	return slices.Clone(_{{$enumTypeName}}Values)
}

// StringValues returns a list of all potential values of this enum as strings.
// Note: This does not return duplicates.
func ({{$enumTypeName}}) StringValues() []string {
	return []string{
	{{- range $val := $values.ValueDeduplicatedSet}}
		"{{$val.Name}}",
	{{- end }}
	}
}

// String returns a string representation of this enum.
// Note: in the case of duplicate values only the first alphabetical definition will be choosen.
func (e {{$enumTypeName}}) String() string {
	switch e {
	{{- range $val := $values.ValueDeduplicatedSet}}
	case {{$val.Name}}:
		return "{{$val.Name}}"
	{{- end }}
	default:
		return fmt.Sprintf("Undefined{{$enumTypeName}}:%d", e)
	}
}

// ParseString will return a value as defined in string form.
func (e {{$enumTypeName}}) ParseString(text string) ({{$enumTypeName}}, error) {
	return Parse{{$enumTypeName}}(text)
}

// Parse{{$enumTypeName}} will attempt to parse the value of a {{$enumTypeName}} from either its string form
// or any value of a trait flagged with the --parsableByTrait flag.
func Parse{{$enumTypeName}}(input any) ({{$enumTypeName}}, error) {
	switch input {
	{{- range $j, $val := $values }}
	case "{{$val.Name}}"
	{{- range $trait := (index $.Traits $i) -}}
	{{- if $trait.Parsable -}}
	{{- $instance := (index $trait.Traits $j) -}}
	, {{$instance.Value}}
	{{- end -}}
	{{- end }}:
		return {{$val.Name}}, nil
	{{- end }}
	default:
		{{- if $.CaseInsensitive }}
		if text, ok := input.(string); ok {
			switch strings.ToLower(text) {
			{{- range $val := $values}}
			case "{{$val.LowerCaseName}}":
				return {{$val.Name}}, nil
			{{- end }}
			}
		}
		{{- end }}
		return 0, fmt.Errorf("`%+v` could not be parsed to enum of type {{$enumTypeName}}", input)
	}
}

// ParseGeneric calls TypedEnum.Parse but returns the result
// in the generic genum.Enum interface. Which is useful when you are only able to work with
// the un-typed interface.
func (e {{$enumTypeName}}) ParseGeneric(input any) (genum.Enum, error) {
	return Parse{{$enumTypeName}}(input)
}


{{- if $.GenJSON }}

// MarshalJSON implements the json.Marshaler interface for {{$enumTypeName}}.
func (e {{$enumTypeName}}) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for {{$enumTypeName}}.
func (e *{{$enumTypeName}}) UnmarshalJSON(data []byte) error {
	// We always support strings.
	var s string
	if err := json.Unmarshal(data, &s); err == nil {
		var err error
		*e, err = Parse{{$enumTypeName}}(s)
		if err == nil {
			return nil
		}

		{{- range $trait := (index $.Traits $i).GetParsableUnderlyingString }}
		*e, err = Parse{{$enumTypeName}}({{$trait.TypeRef}}(s))
		if err == nil {
			return nil
		}
		{{- end }}
	}

	{{- if (len ((index $.Traits $i).GetParsableUnderlyingUint64)) }}
	// uints:
	var uinter64 uint64
	if err := json.Unmarshal(data, &uinter64); err == nil {
		{{- range $trait := (index $.Traits $i).GetParsableUnderlyingUint64 }}
		*e, err = Parse{{$enumTypeName}}({{$trait.TypeRef}}(uinter64))
		if err == nil {
			return nil
		}
		{{- end }}
	}
	{{- end }}

	{{- if (len ((index $.Traits $i).GetParsableUnderlyingInt64)) }}
	// ints:
	var sint64 int64
	if err := json.Unmarshal(data, &sint64); err == nil {
		{{- range $trait := (index $.Traits $i).GetParsableUnderlyingInt64 }}
		*e, err = Parse{{$enumTypeName}}({{$trait.TypeRef}}(sint64))
		if err == nil {
			return nil
		}
		{{- end }}
	}
	{{- end }}


	{{- if (len ((index $.Traits $i).GetParsableUnderlyingFloat64)) }}
	// floats64: (must treat differently than float32- I hate floats.)
	var floater64 float64
	if err := json.Unmarshal(data, &floater64); err == nil {
		{{- range $trait := (index $.Traits $i).GetParsableUnderlyingFloat64 }}
		*e, err = Parse{{$enumTypeName}}({{$trait.TypeRef}}(floater64))
		if err == nil {
			return nil
		}
		{{- end }}
	}
	{{- end }}

	{{- if (len ((index $.Traits $i).GetParsableUnderlyingFloat32)) }}
	// float32:
	var floater32 float32
	if err := json.Unmarshal(data, &floater32); err == nil {
		{{- range $trait := (index $.Traits $i).GetParsableUnderlyingFloat32 }}
		*e, err = Parse{{$enumTypeName}}({{$trait.TypeRef}}(floater32))
		if err == nil {
			return nil
		}
		{{- end }}
	}
	{{- end }}

	{{- if (len ((index $.Traits $i).GetParsableJSONUnmarshalable)) }}
	// native parsing
	{{- range $trait := (index $.Traits $i).GetParsableJSONUnmarshalable }}
	v{{$i}} := *new({{$trait.TypeRef}})
	if err := json.Unmarshal(data, &v{{$i}}); err == nil {
		*e, err = Parse{{$enumTypeName}}(v{{$i}})
		if err == nil {
			return nil
		}
	}
	{{- end }}
	{{- end }}

	return fmt.Errorf("unable to unmarshal {{$enumTypeName}} from `%v`", data)
}
{{- end}}
{{- if $.GenText }}

// MarshalText implements the encoding.TextMarshaler interface for {{$enumTypeName}}.
func (e {{$enumTypeName}}) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for {{$enumTypeName}}.
func (e *{{$enumTypeName}}) UnmarshalText(text []byte) error {
	s := string(text)
	var err error
	*e, err = Parse{{$enumTypeName}}(s)
	if err == nil {
		return nil
	}

	{{- range $trait := (index $.Traits $i).GetParsableUnderlyingString }}
	*e, err = Parse{{$enumTypeName}}({{$trait.TypeRef}}(s))
	if err == nil {
		return nil
	}
	{{- end }}

	return fmt.Errorf("unable to unmarshal {{$enumTypeName}} from `%s`", s)
}
{{- end}}
{{- if $.GenYAML }}

// MarshalYAML implements a YAML Marshaler for {{$enumTypeName}}.
func (e {{$enumTypeName}}) MarshalYAML() (any, error) {
	return e.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for {{$enumTypeName}}.
func (e *{{$enumTypeName}}) UnmarshalYAML(value *yaml.Node) error {
	var err error

	// first try and parse as a string
	*e, err = Parse{{$enumTypeName}}(value.Value)
	if err == nil {
		return nil
	}

	// then try and parse for any string-like traits
	{{- range $trait := (index $.Traits $i).GetParsableUnderlyingString }}
	*e, err = Parse{{$enumTypeName}}({{$trait.TypeRef}}(value.Value))
	if err == nil {
		return nil
	}
	{{- end }}


	{{- if (len ((index $.Traits $i).GetParsableUnderlyingUint64)) }}
	// uints:
	if uinter64, err := strconv.ParseUint(value.Value, 10, 64); err != nil {
		{{- range $trait := (index $.Traits $i).GetParsableUnderlyingUint64 }}
		*e, err = Parse{{$enumTypeName}}({{$trait.TypeRef}}(uinter64))
		if err == nil {
			return nil
		}
		{{- end }}
	}
	{{- end }}


	{{- if (len ((index $.Traits $i).GetParsableUnderlyingInt64)) }}
	// ints:
	if sint64, err := strconv.ParseInt(value.Value, 10, 64); err != nil {
		{{- range $trait := (index $.Traits $i).GetParsableUnderlyingInt64 }}
		*e, err = Parse{{$enumTypeName}}({{$trait.TypeRef}}(sint64))
		if err == nil {
			return nil
		}
		{{- end }}
	}
	{{- end }}


	{{- if (len ((index $.Traits $i).GetParsableUnderlyingFloat64)) }}
	// floats64: (must treat differently than float32- I hate floats.)
	if floater64, err := strconv.ParseFloat(value.Value, 64); err != nil  {
		{{- range $trait := (index $.Traits $i).GetParsableUnderlyingFloat64 }}
		*e, err = Parse{{$enumTypeName}}({{$trait.TypeRef}}(floater64))
		if err == nil {
			return nil
		}
		{{- end }}
	}
	{{- end }}

	{{- if (len ((index $.Traits $i).GetParsableUnderlyingFloat32)) }}
	// float32:
	if floater32, err := strconv.ParseFloat(value.Value, 32); err != nil {
		{{- range $trait := (index $.Traits $i).GetParsableUnderlyingFloat32 }}
		*e, err = Parse{{$enumTypeName}}({{$trait.TypeRef}}(float32(floater32)))
		if err == nil {
			return nil
		}
		{{- end }}
	}
	{{- end }}

	{{- if (len ((index $.Traits $i).GetParsableYAMLUnmarshalable)) }}
	// native parsing
	{{- range $trait := (index $.Traits $i).GetParsableYAMLUnmarshalable }}
	var v{{$i}} {{$trait.TypeRef}}
	if err := v{{$i}}.UnmarshalYAML(value); err == nil {
		*e, err = Parse{{$enumTypeName}}(v{{$i}})
		if err == nil {
			return nil
		}
	}
	{{- end }}
	{{- end }}

	return fmt.Errorf("unable to unmarshal {{$enumTypeName}} from yaml `%s`", value.Value)
}

// IsEnum implements an empty function required to implement Enum.
func ({{$enumTypeName}}) IsEnum() {}

{{- end}}
{{- end}}