// Code generated by genum DO NOT EDIT.
package {{.PkgName}}

import (
	"slices"
	{{- if .GenJSON}}
	"encoding/json"
	{{- end}}
	{{- if .CaseInsensitive}}
	"strings"
	{{- end}}
	{{- if .GenYAML}}
	"gopkg.in/yaml.v3"
	"strconv"
	{{- end}}
	{{- range $import := $.Imports.GetActive}}
	{{$import.Alias}} "{{$import.PkgPath}}"
	{{- end}}
	"fmt"
	"github.com/drshriveer/gtools/genum"
)
{{- range $i, $enumTypeName := .Types}}
{{- $values := (index $.Values $i)}}

var _{{$enumTypeName}}Values = []{{$enumTypeName}}{
{{- range $val := $values.ValueDeduplicatedSet}}
	{{$val.Name}},
{{- end }}
}
{{- range $trait := (index $.Traits $i)}}

// {{$trait.Name}} returns the enum's associated trait of the same name.
// If no trait exists for the enumeration a default value will be returned.
func (e {{$enumTypeName}}) {{$trait.Name}}() {{$trait.TypeRef}} {
	switch e {
	{{- range $instance := $trait.Traits}}
	case {{$instance.OwningValue.Name}}:
		return {{$instance.Value}}
	{{- end }}
	}

	return *new({{$trait.TypeRef}})
}
{{ end }}

// IsValid returns true if the enum value is, in fact, valid.
func (e {{$enumTypeName}}) IsValid() bool {
	{{- /*turns out it's probably faster to do a binary search if there are more than 15 values.*/}}
	{{- if gt (len $values) 15}}
	_, ok := slices.BinarySearch(_{{$enumTypeName}}Values, e)
	return ok
	{{- else}}
	for _, v := range _{{$enumTypeName}}Values {
		if v == e {
			return true
		}
	}
	return false
	{{- end}}
}

// Values returns a list of all potential values of this enum.
func ({{$enumTypeName}}) Values() []{{$enumTypeName}} {
	return slices.Clone(_{{$enumTypeName}}Values)
}

// StringValues returns a list of all potential values of this enum as strings.
// Note: This does not return duplicates.
func ({{$enumTypeName}}) StringValues() []string {
	return []string{
	{{- range $val := $values.ValueDeduplicatedSet}}
		"{{$val.Name}}",
	{{- end }}
	}
}

// String returns a string representation of this enum.
// Note: in the case of duplicate values only the first alphabetical definition will be choosen.
func (e {{$enumTypeName}}) String() string {
	switch e {
	{{- range $val := $values.ValueDeduplicatedSet}}
	case {{$val.Name}}:
		return "{{$val.Name}}"
	{{- end }}
	default:
		return fmt.Sprintf("Undefined{{$enumTypeName}}:%d", e)
	}
}

// Parse{{$enumTypeName}} will attempt to parse the value of a {{$enumTypeName}} from either its string form
// or any value of a trait flagged with the --parsableByTrait flag
func Parse{{$enumTypeName}}(input any) ({{$enumTypeName}}, error) {
	switch input {
	{{- range $j, $val := $values }}
	case "{{$val.Name}}"
	{{- if $.CaseInsensitive -}}
	, "{{$val.LowerCaseName}}"
	{{- end -}}
	{{- range $trait := (index $.Traits $i) -}}
	{{- if $trait.Parsable -}}
	{{- $instance := (index $trait.Traits $j) -}}
	, {{$instance.Value}}
	{{- end -}}
	{{- end }}:
		return {{$val.Name}}, nil
	{{- end }}
	default:
		return 0, fmt.Errorf("`%+v` could not be parsed to enum of type {{$enumTypeName}}", input)
	}
}

// ParseGeneric calls TypedEnum.Parse but returns the result
// in the generic genum.Enum interface. Which is useful when you are only able to work with
// the un-typed interface.
func (e {{$enumTypeName}}) ParseGeneric(input any) (genum.Enum, error) {
	return Parse{{$enumTypeName}}(input)
}

// Parse{{$enumTypeName}}Int attempts to parse an {{$enumTypeName}} from an int value.
// If any parsable traits can be converted to an int then they will be parsed if the
// initial int parsing fails.
func Parse{{$enumTypeName}}Int(i int) ({{$enumTypeName}}, error) {
		e := {{$enumTypeName}}(i)
		if e.IsValid() {
			return e, nil
		}
		{{- range $trait := (index $.Traits $i) }}
		{{- if and $trait.Parsable ($.ConvertibleToInt $trait.Type) }}
		e, err := Parse{{$enumTypeName}}({{$trait.TypeRef}}(i))
		if err == nil {
			return e, nil
		}
		{{- end }}
		{{- end }}
		return e, fmt.Errorf("unable to unmarshal {{$enumTypeName}} from `%d`", i)
}

// Parse{{$enumTypeName}}String attempts to parse an {{$enumTypeName}} from a string value.
// If any parsable traits can be converted to a string then they will be parsed if the
// initial string parsing fails.
func Parse{{$enumTypeName}}String(s string) ({{$enumTypeName}}, error) {
	e, err := Parse{{$enumTypeName}}(s)
	if err == nil {
		return e, nil
	}
	{{- range $trait := (index $.Traits $i) }}
	{{- if and $trait.Parsable ($.ConvertibleToString $trait.Type) }}
	e, err = Parse{{$enumTypeName}}({{$trait.TypeRef}}(s))
	if err == nil {
		return e, nil
	}
	{{- end }}
	{{- end }}
	return e, fmt.Errorf("unable to unmarshal {{$enumTypeName}} from `%s`", s)
}


{{- if $.GenJSON }}

// MarshalJSON implements the json.Marshaler interface for {{$enumTypeName}}.
func (e {{$enumTypeName}}) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for {{$enumTypeName}}.
func (e *{{$enumTypeName}}) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err == nil {
		*e, err = Parse{{$enumTypeName}}String(s)
		if err == nil {
			return nil
		}
	}
	var i int
	if err := json.Unmarshal(data, &i); err == nil {
		*e, err = Parse{{$enumTypeName}}Int(i)
		if err == nil {
			return nil
		}
	}

	return fmt.Errorf("unable to unmarshal {{$enumTypeName}} from `%v`", data)
}
{{- end}}
{{- if $.GenText }}

// MarshalText implements the encoding.TextMarshaler interface for {{$enumTypeName}}.
func (e {{$enumTypeName}}) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for {{$enumTypeName}}.
func (e *{{$enumTypeName}}) UnmarshalText(text []byte) error {
	var err error
	*e, err = Parse{{$enumTypeName}}String(string(text))
	return err
}
{{- end}}
{{- if $.GenYAML }}

// MarshalYAML implements a YAML Marshaler for {{$enumTypeName}}.
func (e {{$enumTypeName}}) MarshalYAML() (any, error) {
	return e.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for {{$enumTypeName}}.
func (e *{{$enumTypeName}}) UnmarshalYAML(value *yaml.Node) error {
	i, err := strconv.ParseInt(value.Value, 10, 64)
	if err == nil {
		*e, err = Parse{{$enumTypeName}}Int(int(i))
		if err == nil {
			return nil
		}
	} else {
		*e, err = Parse{{$enumTypeName}}String(value.Value)
		if err == nil {
			return nil
		}
	}

	return fmt.Errorf("unable to unmarshal {{$enumTypeName}} from yaml `%s`", value.Value)
}

// IsEnum implements an empty function required to implement Enum.
func ({{$enumTypeName}}) IsEnum() {}

{{- end}}
{{- end}}