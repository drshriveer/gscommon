// Code generated by gerrors DO NOT EDIT.
package internal

import (
	"fmt"

	"github.com/drshriveer/gtools/gerrors"
)

// Error implements the "error" interface.
func (e *GRPCError) Error() string {
	const separator = ", "
	result := ""
	if name := e.GError.Name; len(name) > 0 {
		result += "Name: " + name + separator
	}
	if dTag := e.GError.ErrDetailTag(); len(dTag) > 0 {
		result += "DTag: " + dTag + separator
	}
	if src := e.GError.Source; len(src) > 0 {
		result += "Source: " + src + separator
	}
	result += fmt.Sprintf("CustomerMessage: %v", e.CustomerMessage) + separator
	result += fmt.Sprintf("GRPCStatus: %v", e.GRPCStatus) + separator

	result += "Message: " + e.Message

	// FIXME: I think I need a check in here to know the difference between stack types.
	// e.g. if there is only one element, I don't think i care about the rest.
	if stack := e.GError.ErrStack(); len(stack) > 0 {
		result += "\n" + stack.String()
	}

	return result
}

// Base returns a copy of the embedded error without modifications.
func (e *GRPCError) Base() gerrors.Error {
	gerr := e.GError.Base()
	return e.cloneUnderlyingWith(gerr)
}

// Stack returns a copy of the embedded error with a Stack trace and diagnostic info.
func (e *GRPCError) Stack() gerrors.Error {
	gerr := e.GError.Stack()
	return e.cloneUnderlyingWith(gerr)
}

// Src returns a copy of the embedded error with Source populated if needed.
// Source is a limited stack.
func (e *GRPCError) Src() gerrors.Error {
	gerr := e.GError.Src()
	return e.cloneUnderlyingWith(gerr)
}

// ExtMsgf returns a copy of the embedded error with diagnostic info and the
// message extended with additional context.
func (e *GRPCError) ExtMsgf(format string, elems ...any) gerrors.Error {
	gerr := e.GError.ExtMsgf(format, elems...)
	return e.cloneUnderlyingWith(gerr)
}

// DExtMsgf returns a copy of the embedded error with diagnostic info, a detail tag,
// and the message extended with additional context.
func (e *GRPCError) DExtMsgf(detailTag string, format string, elems ...any) gerrors.Error {
	gerr := e.GError.DExtMsgf(detailTag, format, elems...)
	return e.cloneUnderlyingWith(gerr)
}

// DTag returns a copy of the embedded error with diagnostic info and a detail tag.
func (e *GRPCError) DTag(detailTag string) gerrors.Error {
	gerr := e.GError.DTag(detailTag)
	return e.cloneUnderlyingWith(gerr)
}

// Convert will attempt to convert the supplied error into a gError.Error of the
// Factory's type, including the source errors details in the result's error message.
// The original error can be retrieved via utility methods.
func (e *GRPCError) Convert(err error) gerrors.Error {
	gerr := e.GError.Convert(err)
	return e.cloneUnderlyingWith(gerr)
}

func (e *GRPCError) Is(err error) bool {
	if err == e {
		return true
	}
	else if e.Unwrap()
	if e.GError
}

func (e *GRPCError) cloneUnderlyingWith(gerr gerrors.Error) gerrors.Error {

	// FIX THIS GAVIN . This is the problem where are we setting the correct source srcFactory?!
	// we are only getting the _gerror_
	gr := gerr.(*gerrors.GError)
	result := &GRPCError{
		GError:     *gr,
		GRPCStatus: e.GRPCStatus,
		Timeout:    e.Timeout,
	}
	return result
}
