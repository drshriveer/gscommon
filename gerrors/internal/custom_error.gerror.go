// Code generated by gerrors DO NOT EDIT.
package internal

import (
	"fmt"

	"github.com/drshriveer/gtools/gerrors"
)

// Error implements the "error" interface.
func (e *GRPCError) Error() string {
	const separator = ", "
	result := ""
	if name := e.GError.Name; len(name) > 0 {
		result += "Name: " + name + separator
	}
	if dTag := e.GError.ErrDetailTag(); len(dTag) > 0 {
		result += "DTag: " + dTag + separator
	}
	if src := e.GError.Source; len(src) > 0 {
		result += "Source: " + src + separator
	}
	result += fmt.Sprintf("CustomerMessage: %v", e.CustomerMessage) + separator
	result += fmt.Sprintf("GRPCStatus: %v", e.GRPCStatus) + separator

	result += "Message: " + e.Message

	// Note: right now if we have a "source stack", we actually remove the stack after calculations.
	if stack := e.GError.ErrStack(); len(stack) > 0 {
		result += "\n" + stack.String()
	}

	return result
}

// Base returns a copy of the embedded error without modifications.
func (e *GRPCError) Base() gerrors.Error {
	clone := gerrors.CloneBase(e, gerrors.NoStack, "", "", nil)
	return e.toPrimaryType(clone)
}

// Convert will attempt to convert the supplied error into a gError.Error of the
// Factory's type, including the source errors details in the result's error message.
// The original error can be retrieved via utility methods.
func (e *GRPCError) Convert(err error) gerrors.Error {
	if gerr, ok := err.(gerrors.Error); ok {
		return gerr
	}
	clone := gerrors.CloneBase(e,
		gerrors.DefaultStack,
		"",
		fmt.Sprintf("originalError: %+v", err),
		err,
	)
	return e.toPrimaryType(clone)
}

// DTag returns a copy of the embedded error with diagnostic info and a detail tag.
func (e *GRPCError) DTag(detailTag string) gerrors.Error {
	clone := gerrors.CloneBase(e,
		gerrors.DefaultStack,
		detailTag,
		"",
		nil,
	)

	return e.toPrimaryType(clone)
}

// DExtMsgf returns a copy of the embedded error with diagnostic info, a detail tag,
// and the message extended with additional context.
func (e *GRPCError) DExtMsgf(detailTag string, format string, elems ...any) gerrors.Error {
	clone := gerrors.CloneBase(e,
		gerrors.DefaultStack,
		detailTag,
		fmt.Sprintf(format, elems...),
		nil,
	)
	return e.toPrimaryType(clone)
}

// ExtMsgf returns a copy of the embedded error with diagnostic info and the
// message extended with additional context.
func (e *GRPCError) ExtMsgf(format string, elems ...any) gerrors.Error {
	clone := gerrors.CloneBase(e,
		gerrors.DefaultStack,
		"",
		fmt.Sprintf(format, elems...),
		nil,
	)
	return e.toPrimaryType(clone)
}

// Src returns a copy of the embedded error with Source populated if needed.
// Source is a limited stack.
func (e *GRPCError) Src() gerrors.Error {
	clone := gerrors.CloneBase(e, gerrors.SourceStack, "", "", nil)
	return e.toPrimaryType(clone)
}

// Stack returns a copy of the embedded error with a Stack trace and diagnostic info.
func (e *GRPCError) Stack() gerrors.Error {
	clone := gerrors.CloneBase(e, gerrors.DefaultStack, "", "", nil)
	return e.toPrimaryType(clone)
}

// toPrimaryType accepts a base gerror and will populate clone fields.
func (e *GRPCError) toPrimaryType(gerr *gerrors.GError) gerrors.Error {
	result := &GRPCError{
		GError:     *gerr,
		GRPCStatus: e.GRPCStatus,
		Timeout:    e.Timeout,
	}
	return result
}
